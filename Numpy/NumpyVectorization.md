## 벡터화 - 벡터 연산
- 같은 형태(shape)의 배열(벡터, 행렬)간의 연산은 같은 index의 원소끼리 연산을 한다. 
    - **Element-wise(원소별) 연산** 이라고도 한다.
    - 배열간의 연산시 배열의 형태가 같아야 한다.
    - 배열의 형태가 다른 경우 Broadcast 조건을 만족하면 연산이 가능하다.

## 내적 (Dot product)
- `@` 연산자 또는 `numpy.dot(벡터/행렬, 벡터/행렬)`  함수 사용

### 벡터간의 내적
- 같은 index의 원소끼리 곱한뒤 결과를 모두 더한다.
- 벡터간의 내적의 결과는 스칼라가 된다.
- x.y 또는 x^Ty로 표현
- 조건
	- 두 벡터의 차원(원소의개수)가 같아야 한다.
	- 앞의 벡터는 행벡터 뒤의 벡터는 열벡터 이어야 한다.
	- numpy 에서는 vector 끼리 연산시 앞의 벡터는 행벡터로 뒤의 벡터는 열벡터로 인식해 처리한다.

### 행렬간의 내적
- 앞 행렬의 행과 뒤 행렬의 열간에 내적을 한다.
- 행렬과 행렬을 내적하면 그 결과는 행렬이 된다.
- ```앞 행렬의 열수와 뒤 행렬의 행수```가 같아야 한다.
- 내적의 결과의 형태(shape)는 **앞행렬의 행수와 뒤 행렬의 열의 형태**를 가진다.
	- (**3** x ```2)와 (2``` x **5**) = (**3 x 5**)
	- (**1** x ```5)와 (5``` x **1**) = (**1 x 1**)  

# 범용함수(Ufunc, Universal function)
## 범용함수란
- 벡터화를 지원하는 넘파이 연산 함수들.
	- 유니버셜 뜻이 **"전체에 영향을 미치는"** 이다. 그래서 이 함수는 배열의 원소 전체에 영향을 미치는 기능을 제공하는 함수다.
	- 배열의 원소별로 연산을 처리하는 함수들
- 반복문을 사용해 연산하는 것 보다 유니버셜 함수를 사용하는 것이 속도가 빠르다.	
## 단항 범용함수(unary ufunc)
- 매개변수로 한개의 배열을 받는다.
- 한 배열내의 원소별로 연산  
![image](/images/unary.png)

## 단항 범용함수(unary ufunc)
- 매개변수로 한개의 배열을 받는다.
- 한 배열내의 원소별로 연산  
![image](/images/polynomial.png)

## reduce()
- 결과가 하나만 남을 때 까지 해당 연산을 배열의 모든 요소에 반복해서 적용
- 구문
	- np.**이항범용함수이름**.reduce(배열, axis=0)
- 처리결과의 축의개수(rank)는 하나 줄어 든다.
```python
y = np.arange(1, 25).reshape(3, 4, 2)
print(y.shape)
>>> (3, 4, 2)
r = np.add.reduce(y, axis=0) # 행방향으로 연산
print(r.shape)
>>> (4, 2)
r1 = np.add.reduce(y, axis=1) # 열방향으로 연산.
print(r1.shape)
>>> (3, 2)
```
	
## 누적연산함수 - accumulate()
- 배열의 원소들에 해당연산을 누적해 적용
- 처리경과의 축의개수(rank)는 피연산자배열과 동일하다.
- 구문
	- np.**이항범용함수이름**.accumulate(배열, axis=0)	
	
## 기술통계함수
- 통계 결과를 계산해 주는 함수들
- 구문
    1. np.전용함수(배열)
        - np.sum(x)
    2. 일부는 배열.전용함수() 구문 지원
        - x.sum()
- 배열의 원소 중 누락된 값(NaN - Not a Number) 있을 경우 연산의 결과는 NaN으로 나온다.        
- 안전모드 함수
    - 배열내 누락된 값(NaN)을 무시하고 계산
![image](/images/01.png)	
- ```np.median```활용
	- 이상치(outlier),극단치: 일반적인 대다수 분포에서 벗어난 값.
	- 극단치 평균 왜곡 가능. 극단치 값이 있을 경우 평균의 대표값 신뢰성 문제.
	- median: 중위수 중앙값.
	- 극단치로 인한 평균 왜곡시 median활용 중앙값 활용.
